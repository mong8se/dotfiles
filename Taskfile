#!/usr/bin/env bash

# https://github.com/adriancooney/Taskfile

set -e

VI_BIN=$(command -v nvim || command -v vim || command -v vi | tr -d "\n")

ELEVATOR=$(command -v doas || command -v sudo | tr -d "\n" )

export REPO_LOCATION="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
cd $REPO_LOCATION

function com_ex {
  command -v $1 > /dev/null
}

function nope {
  echo Error: $@ >&2
  exit 1
}

com_ex bc || nope "bc must be installed!"

com_ex cargo || com_ex deno || nope "Either rust or deno must be installed!"

function hostname {
  echo $HOST42
  echo
}

function submodule:init {
  git submodule update --init --recursive
}

function submodule:update {
  git submodule update --remote
}

function vi:install {
  echo -n "Installing vi plugs ..."
  ${VI_BIN} -u home/config/nvim/lua/lazy-init.lua -V1 --headless -es +"Lazy install"
  echo " done."
}

function vi:sync {
  echo -n "Updating vi plugs ..."
  ${VI_BIN} -u home/config/nvim/lua/lazy-init.lua -V1 --headless -es +"Lazy sync"
  echo " done."
}

function vi:cleanup {
  echo -n "Cleaning up vi plugs ..."
  ${VI_BIN} -u home/config/nvim/lua/lazy-init.lua -V1 --headless -es +"Lazy clean"
  echo " done."
}

function deno:install {
  export ASDF_DIR="$REPO_LOCATION/Resources/asdf"
  export ASDF_DATA_DIR="$ASDF_DIR"
  . $ASDF_DIR/asdf.sh
  asdf plugin add deno
  deno:upgrade
}

function deno:upgrade {
  export ASDF_DIR="$REPO_LOCATION/Resources/asdf"
  export ASDF_DATA_DIR="$ASDF_DIR"
  . $ASDF_DIR/asdf.sh
  asdf install deno latest
  asdf global deno latest
}

function homebrew:install {
  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
}

function homebrew:bundle {
  brew bundle --no-lock --file $REPO_LOCATION/Resources/Brewfile
}

function os:upgrade {
  case "$(uname -s)" in
    Linux)
      source /etc/os-release
      case $ID in
        arch)
          $ELEVATOR bash -c 'pacman -Sy; pacman -Qu archlinux-keyring && pacman -S archlinux-keyring; pacman -Su'
          ;;
        fedora)
          $ELEVATOR dnf upgrade --refresh
          ;;
        *)
          echo "Linux distro is unrecognized."
          ;;
      esac
      ;;
    Darwin)
      brew update && brew upgrade
    ;;
    *)
      echo "OS is unrecognized."
    ;;
  esac

}

function test() {
  cd Resources/linkOmatic
  deno run --allow-write __tests__/generateDeps.ts
  deno test --allow-read --allow-env --allow-net --import-map=__tests__/importMap.json
}

function lom:install {
  cargo install --git https://github.com/mong8se/link_o_matic.git
}

com_ex link_o_matic && LINKO="link_o_matic" || LINKO="deno -q run --allow-read --allow-write --allow-env ""$REPO_LOCATION/Resources/linkOmatic/cli.ts"

function cleanup {
  $LINKO cleanup
}

function autocleanup {
  $LINKO autocleanup
}

function implode {
  $LINKO implode
}

function install {
  $LINKO install
}

function sync {
  install
  autocleanup
}

function init {
  submodule:init
  submodule:update
  com_ex cargo && lom:install || deno:install
  export PATH="$PATH:~/.cargo/bin"
  install
  vi:install
}

function upgrade {
  os:upgrade
  submodule:update
  sync
  com_ex cargo && lom:install || deno:install
  vi:sync
}

function default {
  sync
}

function help {
  echo "$0 <task> <args>"
  echo "Tasks:"
  compgen -A function | grep -v 'help\|default' | cat -n
  echo
  type default | sed -e '1d; 2s/()/task:/; s/^/    /'
  echo
}

# What do you get if you multiply six by nine
export HOST42

# set up an array of our base 42 characters
# to look up each digit against
BASE42=($(echo {0..8} {a..z} M O A Z A M I))
# Repeating A and M will cause collisions but for
# this use case, odds are slim it will matter

MD5_CMD=$(command -v md5 || command -v md5sum | tr -d "\n" )
# trim new line and md5 the hostname
MD5=$(/bin/hostname | tr -d "\n" | $MD5_CMD)

# switch to lower case because bc demands it
# strip trailing *stdin\n from md5sum output
HEXVALUE=$(tr "[:lower:]" "[:upper:]" <<< ${MD5/ *})

# it's important obase come before ibase so you can
# specify the obase in base 10. Otherwise you have
# to specify the obase in the base of the ibase
for i in $(BC_LINE_LENGTH=42 bc <<< "obase=42; ibase=16; $HEXVALUE"); do

  # We're using bc's built in line break
  # to truncate at 13 characters

  # bc is going to output each digit as a zero led
  # two digit string followed by a space (3 chars):
  #
  #   01 35 12

  # so we're setting its line length to
  #    3 chars x (13 + 1) = 42

  # after that bc puts a \ and a new line
  # so we detect the \ and break the loop
  if [ $i = '\' ] ; then break ; fi

  # we need to cast to base 10 in the array
  # look up because bash will barf on the
  # leading zeros
  HOST42=$HOST42${BASE42[$(( 10#$i ))]}
done

TIMEFORMAT="Task completed in %3lR"
time "${@:-default}"
