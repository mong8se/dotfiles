#!/usr/bin/env bash

# https://github.com/adriancooney/Taskfile

set -e

ELEVATOR=$(command -v doas || command -v sudo | tr -d "\n" )

export REPO_LOCATION="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
cd $REPO_LOCATION

function com_ex {
  command -v $1 > /dev/null
}

function nope {
  echo Error: ${@}! >&2
  exit 1
}

com_ex bc || nope "bc must be installed"

com_ex cargo || nope "rust must be installed"

function task:hostname {
  : "Print hash of hostname"

  echo $HOST42
  echo
}

function task:submodule:init {
  : "Init git submodules"

  git submodule update --init --recursive
}

function task:submodule:update {
  : 'Update your submodules'

  git submodule update --remote
}

VI_BIN="$(command -v nvim || command -v vim || command -v vi | tr -d "\n") -u home/config/nvim/lua/bootstrap.lua --headless"
function task:vi:install {
  : 'Install Lazy plugins for neovim'

  echo -n "Installing vi plugs ..."
  ${VI_BIN} "+Lazy! install" +qa
  echo " done."
}

function task:vi:sync {
  : 'Sync Lazy plugins for neovim'

  echo -n "Updating vi plugs ..."
  ${VI_BIN} "+Lazy! sync" +qa
  echo " done."
}

function task:vi:cleanup {
  : 'Clean up Lazy plugins for neovim'

  echo -n "Cleaning up vi plugs ..."
  ${VI_BIN} "+Lazy! clean" +qa
  echo " done."
}

function task:homebrew:install {
  : "Install homebrew"

  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
}

function task:homebrew:bundle {
  : "Install homebrew bundle"

  brew bundle --no-lock --file $REPO_LOCATION/Resources/Brewfile
}

function task:os:upgrade {
  : "Upgrade OS"

  case "$(uname -s)" in
    Linux)
      source /etc/os-release
      case $ID in
        arch)
          $ELEVATOR bash -c 'pacman -Sy; pacman -Qu archlinux-keyring && pacman -S archlinux-keyring; pacman -Su'
          ;;
        fedora)
          $ELEVATOR dnf upgrade --refresh
          ;;
        *)
          echo "Linux distro is unrecognized."
          ;;
      esac
      ;;
    Darwin)
      brew update && brew upgrade
    ;;
    *)
      echo "OS is unrecognized."
    ;;
  esac

}

function task:lom:install {
  : 'Install link_o_matic via cargo'

  cargo install --git https://github.com/mong8se/link_o_matic.git
}

function link_it {
  com_ex link_o_matic && link_o_matic $1 || nope "link_o_matic must be installed with task lom:install"
}

function task:cleanup {
  : "Clean up stale symlinks that point to .dotfiles/"

  link_it cleanup
}

function task:autocleanup {
  : "Clean up stale symlinks that point to .dotfiles/ without prompting"

  link_it autocleanup
}

function task:implode {
  : "Remove all symlinks that point to .dotfiles/ without asking"
  link_it implode
}

function task:install {
  : "Install symlinks to .dotfiles/home"

  link_it install
}

function task:sync {
  : "Install and cleanup symlinks to .dotfiles/home"

  task:install
  task:autocleanup
}

function task:init {
  : "Bootstrap a new install"

  task:submodule:init
  task:submodule:update
  com_ex cargo && task:lom:install
  export PATH="$PATH:~/.cargo/bin"
  task:install
  task:vi:install
}

function task:upgrade {
  : "Upgrade links, os, submodules, and vi"

  com_ex cargo && task:lom:install
  task:sync
  task:os:upgrade
  task:submodule:update
  task:vi:sync
}

function task:default {
  task:sync
}

function task:help {
  : "Prints this help"

  echo "$0 <task> <args>"
  echo
  echo "Tasks:"
  for task in $(compgen -A function | sed -nE '/default/d; s/task:(.*)/\1/p')
  do
    task:describe $task
  done
  echo
  task:explain default
}

COLON_COMMENT_PATTERN=" *: *\(['"'"'"]\)\(.*\)\1;"
function getTask {
  type "task:$1"
}

function task:describe {
  : "Prints description of task"

  printf '    %-16s | %s\n' $1 "$(getTask $1 | sed -ne "s/${COLON_COMMENT_PATTERN}/\2/p")"
}

function task:explain {
  : "Prints definition of task"

  printf '%s => %s\n' $1 "$(getTask $1 | sed -e "1,2d; /${COLON_COMMENT_PATTERN}/d;")"
}

# What do you get if you multiply six by nine

# set up an array of our base 42 characters
# to look up each digit against
BASE42=($(echo {0..8} {a..z} M O A Z A M I))
# Repeating A and M will cause collisions but for
# this use case, odds are slim it will matter

MD5_CMD=$(command -v md5 || command -v md5sum | tr -d "\n" )
# trim new line and md5 the hostname
MD5=$(/bin/hostname | tr -d "\n" | $MD5_CMD)

# switch to lower case because bc demands it
# strip trailing *stdin\n from md5sum output
HEXVALUE=$(tr "[:lower:]" "[:upper:]" <<< ${MD5/ *})

# it's important obase come before ibase so you can
# specify the obase in base 10. Otherwise you have
# to specify the obase in the base of the ibase
export HOST42=$(
  for i in $(
    BC_ENV_ARGS="" BC_LINE_LENGTH=42 bc <<< "obase=42; ibase=16; $HEXVALUE"
  )
  do
    # We're using bc's built in line break
    # to truncate at 13 characters

    # bc is going to output each digit as a zero led
    # two digit string followed by a space (3 chars):
    #
    #   01 35 12

    # so we're setting its line length to
    #    3 chars x (13 + 1) = 42

    # after that bc puts a \ and a new line
    # so we detect the \ and break the loop
    if [ $i = '\' ] ; then break ; fi

    # we need to cast to base 10 in the array
    # look up because bash will barf on the
    # leading zeros
    echo -n ${BASE42[$(( 10#$i ))]}
  done
)

TIMEFORMAT="Task completed in %3lR"
time "task:${@:-default}"
